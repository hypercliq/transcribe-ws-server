<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Audio Streaming Client</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f4f9;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: #333;
    }

    .controls {
      margin: 20px 0;
    }

    .controls button {
      margin-right: 15px;
      padding: 10px 25px;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .controls button#start {
      background-color: #4CAF50;
      color: white;
    }

    .controls button#start:hover {
      background-color: #45a049;
    }

    .controls button#stop {
      background-color: #f44336;
      color: white;
    }

    .controls button#stop:hover {
      background-color: #da190b;
    }

    .controls button#clear {
      background-color: #008CBA;
      color: white;
    }

    .controls button#clear:hover {
      background-color: #007bb5;
    }

    #transcription {
      width: 100%;
      max-width: 600px;
      min-height: 250px;
      border: 2px solid #ccc;
      border-radius: 10px;
      padding: 20px;
      background-color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      font-size: 1.1em;
      color: #333;
    }

    .final {
      color: #000;
    }

    .partial {
      color: #555;
      font-style: italic;
    }

    #error-message {
      margin-top: 15px;
      color: #e74c3c;
      font-weight: bold;
    }

    @media (max-width: 600px) {
      .controls button {
        margin-bottom: 10px;
        width: 100%;
      }

      #transcription {
        width: 90%;
      }
    }
  </style>
</head>

<body>
  <h1>Audio Streaming Client</h1>

  <div class="controls">
    <button id="start">Start Streaming</button>
    <button id="stop" disabled>Stop Streaming</button>
    <button id="clear">Clear Transcription</button>
  </div>

  <div id="transcription" aria-live="polite"></div>
  <div id="error-message" role="alert"></div>

  <script>
    const startButton = document.getElementById('start');
    const stopButton = document.getElementById('stop');
    const clearButton = document.getElementById('clear');
    const transcriptionDiv = document.getElementById('transcription');
    const errorMessageDiv = document.getElementById('error-message');

    let ws;
    let audioContext;
    let processor;
    let input;
    let partialSpan = null;

    startButton.addEventListener('click', async () => {
      // Disable the start button immediately to prevent multiple connections
      startButton.disabled = true;

      const token = 'your-hardcoded-auth-token'; // Ensure this matches the server's AUTH_TOKEN

      // Initialize WebSocket with the token as the subprotocol
      ws = new WebSocket('ws://localhost:8080', token);

      ws.addEventListener('open', () => {
        console.log('Connected to server');
        stopButton.disabled = false;
        errorMessageDiv.textContent = '';
      });

      ws.addEventListener('message', (event) => {
        if (event.data) {
          try {
            const message = JSON.parse(event.data);
            if (message.partialTranscript) {
              updatePartialTranscript(message.partialTranscript);
            } else if (message.transcript) {
              appendFinalTranscript(message.transcript);
            } else if (message.error) {
              console.error('Server error:', message.error);
              displayError(message.error);
            } else {
              console.log('Received message:', message);
            }
          } catch (err) {
            console.error('Error parsing message:', err);
            displayError('Received invalid message from server.');
          }
        }
      });

      ws.addEventListener('close', (event) => {
        console.log(`Disconnected from server (code: ${event.code}, reason: ${event.reason})`);
        startButton.disabled = false;
        stopButton.disabled = true;
        if (event.code !== 1000) { // 1000 indicates normal closure
          displayError('Disconnected from server unexpectedly.');
        }
      });

      ws.addEventListener('error', (err) => {
        console.error('WebSocket error:', err);
        displayError('WebSocket encountered an error.');
        startButton.disabled = false;
        stopButton.disabled = true;
      });

      // Initialize Audio Context
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const originalSampleRate = audioContext.sampleRate;
      console.log('Original sample rate:', originalSampleRate);

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        input = audioContext.createMediaStreamSource(stream);

        processor = audioContext.createScriptProcessor(1024, 1, 1);

        processor.onaudioprocess = (e) => {
          const inputData = e.inputBuffer.getChannelData(0);

          // Resample the audio data to 16,000 Hz
          const resampledData = downsampleBuffer(inputData, originalSampleRate, 16000);

          // Convert to 16-bit PCM
          const pcmData = floatTo16BitPCM(resampledData);

          // Send the resampled and formatted audio data to the server
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(pcmData);
          }
        };

        input.connect(processor);
        processor.connect(audioContext.destination);
      } catch (err) {
        console.error('Error accessing microphone:', err);
        displayError('Could not access your microphone. Please check permissions.');
        startButton.disabled = false; // Re-enable if microphone access fails
      }
    });

    stopButton.addEventListener('click', () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close(1000, 'User initiated closure'); // 1000 indicates normal closure
      }
      if (processor && audioContext) {
        processor.disconnect();
        audioContext.close();
      }
      console.log('Streaming stopped');
      stopButton.disabled = true;
      startButton.disabled = false;
    });

    clearButton.addEventListener('click', () => {
      transcriptionDiv.innerHTML = '';
      partialSpan = null;
      errorMessageDiv.textContent = '';
      console.log('Transcription cleared');
    });

    function updatePartialTranscript(partialTranscript) {
      if (!partialSpan) {
        // Create a new partial transcript span if it doesn't exist
        partialSpan = document.createElement('span');
        partialSpan.className = 'partial';
        transcriptionDiv.appendChild(partialSpan);
      }

      // Update the textContent of the partial transcript span
      partialSpan.textContent = partialTranscript + ' ';
      // Auto-scroll to the bottom
      transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight;
    }

    function appendFinalTranscript(transcript) {
      // Remove the partial transcript span if it exists
      if (partialSpan) {
        transcriptionDiv.removeChild(partialSpan);
        partialSpan = null;
      }

      // Append the final transcript
      const finalSpan = document.createElement('span');
      finalSpan.className = 'final';
      finalSpan.textContent = transcript + ' ';
      transcriptionDiv.appendChild(finalSpan);
      // Auto-scroll to the bottom
      transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight;
    }

    function displayError(message) {
      errorMessageDiv.textContent = message;
    }

    // Functions for audio processing
    function downsampleBuffer(buffer, sampleRate, outSampleRate) {
      if (outSampleRate >= sampleRate) {
        return buffer;
      }
      const sampleRateRatio = sampleRate / outSampleRate;
      const newLength = Math.round(buffer.length / sampleRateRatio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function floatTo16BitPCM(input) {
      const buffer = new ArrayBuffer(input.length * 2);
      const output = new DataView(buffer);
      for (let i = 0; i < input.length; i++) {
        let s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return buffer;
    }
  </script>
</body>

</html>
